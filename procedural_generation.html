<html>
  <head>
    <title>Simple Geometry Test</title>
  </head>

  <style>
  body {margin: 0;}
  canvas {width: 100%; height: 100%;}
  </style>

  <body>
	<link rel="shortcut icon" href="#">

   
    <style>
    			body {
    				font-family: Monospace;
    				background-color: #000;
    				color: #fff;
    				margin: 0px;
    				overflow: hidden;
    			}
    			#info {
    				position: absolute;
    				top: 10px;
    				width: 100%;
    				text-align: center;
    			}
    </style>

    <div id="info">
      <p>This is the first example using threeJS<br>
      left button to rotate the scene, scroll to zoom in/out</p>
    </div>

		<script type="importmap">
			{
				"imports": {
					"three": "./build/three.module.js",
          "three-noise": "./build/three-noise.module.js"
				}
			}
		</script>
		
	<script type="module">

    
	import * as THREE from 'three';
	import { OrbitControls } from './build/controls/OrbitControls.js';
  import { FBM } from "three-noise";
  
    const fbm = new FBM( {
      seed: Math.random(),
      scale: 0.06, // lower numbers make islands bigger (more zoomed)
      octaves: 6,
      persistence: 0.6,
      lucunarity: 2,
      redistribution: 1,
      height: 0
    });



    // PARAMETERS
    var map_width = 50;
    var map_breadth = 50;

    var block_height = 20; // flatness of the map
    var light_intensity = 2.5;
    var light_height = 15;



    //create the scene
    var scene = new THREE.Scene( );
    var ratio = window.innerWidth/window.innerHeight;
    //create the perspective camera
    //for parameters see https://threejs.org/docs/#api/cameras/PerspectiveCamera
    var camera = new THREE.PerspectiveCamera(45,ratio,1,1000);

    //set the camera position
    camera.position.set(map_width / 2,60,120);

    // set up light
    const pointLight = new THREE.PointLight( 0xffffff, light_intensity, 1800 );
    scene.add( pointLight );
    pointLight.position.set(map_width/2, light_height, map_width/2);
    

    //create the webgl renderer
    var renderer = new THREE.WebGLRenderer( );

    //set the size of the rendering window
    renderer.setSize(window.innerWidth,window.innerHeight);

    //add the renderer to the current document
    document.body.appendChild(renderer.domElement );

    //create the mesh of a cube
    var geometry_cube = new THREE.BoxGeometry(1,1,1);
    var cubes=[];
    
    function CreateScene()
    {
      for (var x = 0; x < map_width; x++) {
        for (var z = 0; z < map_breadth; z++) {
          //create the material of the cube (basic material)
          var material_cube = new THREE.MeshLambertMaterial();
          //set the color of the cube
          material_cube.color=  new THREE.Color(0,1,0);
          //then set the renderer to wireframe
          material_cube.wireframe=false;

          //all the transformation are 4x4 matrices as
          var rot2 = new THREE.Matrix4();
          var sca = new THREE.Matrix4();
          var rot = new THREE.Matrix4();
          var tra = new THREE.Matrix4();
          var combined = new THREE.Matrix4();

          
          var rand_height = fbm.get2(new THREE.Vector2(x, z));
          sca.makeScale(1, rand_height * block_height,1);
          tra.makeTranslation (x, 0.5 * rand_height * block_height, z);

          combined.multiply(tra);
          combined.multiply(sca);

          if (rand_height > 1.7 * 0.25) { material_cube.color= new THREE.Color(0.65, 1.0, 0.76);}
          else if (rand_height > 1.5 * 0.25) { material_cube.color= new THREE.Color(0.3, 0.8, 0.3);}
          else if (rand_height > 1.3 * 0.25) { material_cube.color= new THREE.Color(0.3, 0.8, 0.3);}
          else if (rand_height > 1.1 * 0.25) { material_cube.color= new THREE.Color(0.3, 0.8, 0.3);}
          else if (rand_height > 0.9 * 0.25) { material_cube.color= new THREE.Color(0.1, 0.75, 0.1);}
          else if (rand_height > 0.8 * 0.25) { material_cube.color= new THREE.Color(0, 0.7, 0);}
          else if (rand_height > 0.6 * 0.25) { material_cube.color= new THREE.Color(0, 0.6, 0);}
          else if (rand_height > 0.5 * 0.25) { material_cube.color= new THREE.Color(0, 0.5, 0);}
          else if (rand_height > 0.3 * 0.25) { material_cube.color= new THREE.Color(0, 0.35, 0);}
          else if (rand_height > 0.1 * 0.25) { material_cube.color= new THREE.Color(0, 0.2, 0);}
          else if (rand_height > 0.25 * 0.25) { material_cube.color= new THREE.Color(0, 0, 1.0);}
          else if (rand_height > 0.1 * 0.25) { material_cube.color= new THREE.Color(0, 0, 0.85);}
          else if (rand_height > -0.2 * 0.25) { material_cube.color= new THREE.Color(0, 0, 0.7);}
          else if (rand_height > -0.9 * 0.25) { material_cube.color= new THREE.Color(0.015, 0.015, 0.5);}
          else if (rand_height > -1.7 * 0.25) { material_cube.color= new THREE.Color(0.01, 0.01, 0.45);}
          else { material_cube.color= new THREE.Color(0.01, 0.01, 0.4);}

          cubes[x * map_width + z] = new THREE.Mesh(geometry_cube,material_cube);
          cubes[x * map_width + z].applyMatrix4(combined);

          scene.add(cubes[x * map_width + z]);
        }
      }
      

    }
 
  CreateScene();
  //////////////
	// CONTROLS //
	//////////////

	// move mouse and: left   click to rotate,
	//                 middle click to zoom,
	//                 right  click to pan
  // add the new control and link to the current camera to transform its position

  var controls = new OrbitControls( camera, renderer.domElement );
  //controls.autoRotate = true;
  controls.target = new THREE.Vector3(map_width/2,10,map_width/2);

  controls.autoRotate = true;
  

  // final update loop
  var MyUpdateLoop = function ( )
  {
    
    controls.update();

    // call the render with the scene and the camera
    renderer.render(scene,camera);

    // finally perform a recursive call to update again
    // this must be called because the mouse changes the camera position
    requestAnimationFrame(MyUpdateLoop);

  };

  requestAnimationFrame(MyUpdateLoop);

  // this function is called when the window is resized
  var MyResize = function ( )
  {
    var width = window.innerWidth;
    var height = window.innerHeight;
    renderer.setSize(width,height);
    camera.aspect = width/height;
    camera.updateProjectionMatrix();
    renderer.render(scene,camera);
  };

  // link the resize of the window to the update of the camera
  window.addEventListener( 'resize', MyResize);
    </script>
  </body>
</html>
